RCPU (do not forget to rename) prototype specification:

Registers:

A (16) - general purpose register + address register
B, C (16) - general purpose registers
PC (16) - program counter
SP (16) - stack pointer
F (4) - flag register
_________
|C|N|Z|V|
C = carry,
N = negative,
Z = zero,
V = overflow;

Read addressing modes:

Zero = 0
Register A = A
Register B = B
Register C = C
ImmediateBig = PEEK(PC+1)
Absolute  = PEEK(PEEK(PC+1))
Adressed = PEEK(A)
Absolute Indexed = PEEK(PEEK(PC+1) + A)

Desigantions:
R - register,
M - memory address,
I - immediate

Instructions:

A type:
|0000|S1(3)|Opcode(4)|S0(2)|D(3)|
Flags: cnzv

ADD/SUB/ADC/SBC R, R/M/I, R/M: //0b0000-0011
d = s0 +/- s1 (+/- carry)?;

MUL R, R/M/I, R/M: //0b0100
{A, d} = s0 * s1;

MLL R, R/M/I, R/M: //0b0101
d = s0 * s1;

SGN R, R/M/I, R/M //0b0110
d = {s0[15], s1[14:0]}

RAS R, R/M/I, R/M: //0b0111
d = s0 >(arithmetic)> s1;

LSH/RSH/LRT/RRT R, R/M/I, R/M: //0b1000-1011
d = s0 <</>> s1;

AND/OR/XOR R, R/M/I, R/M: //0b1100-1110
d = s0 &/|/^ s1;

NOT R/M/I, R/M: //0b1111
d = ~s1;



J Type:
|1|Address(15)|
Flags: ----

JMP I: //0b0
PC = {PC[15], a0};



I Type:
|01|Opcode(2)|D(3)|Opcode(1)|Immediate(8)|
Flags: cnzv

ADDI/SUBI/ADCI/SBCI R/M, I: //0b00-11 | 0
d = d +/- (s)i +/- (carry)?;

ANDI/ORI/XORI R/M, I: //0b00-10 | 1
d = d &/|/^ i;


SI Type:
|0001|S(3)|Opcode(2)|D(3)|Immediate(4)|
Flags: cznv

LSHI/RSHI/ROTI/RASI R/M/I, I, R/M:
a2 = a0 <</>> a1;



F Type:
|010000|Opcode(2)|C(2)|N(2)|Z(2)|V(2)|

JFA/JFO I: (JEQ, JNE, JLT, JGT, JLE, JGE, JCS, JCC, JVS, JVC) //0b00-01
If all/any of chosen flags equals chosen value;
    PC = a0;

FLG I: (CST, CCL, VST, VCL, NST, NCL, ZST, ZCL)
Set/clear chosen flags;



SP Type:
|0011|Opcode(1)|S(4)|

PUSH R/M/I: //0b0
Mem[SP] = s;
SP = SP + 1;

POP R/M/I: (RET)//0b1
SP = SP - 1;
s = Mem[SP];
