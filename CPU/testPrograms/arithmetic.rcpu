#defmacro add32 [rmi, rmi, r, r, rm, rm] ; $add32 (int32 a, int32 b, int32 out)
    add $2, $4, $6
    adc $1, $3, $5
enddef

mul32: ; int32 mul32 (int32 a, int32 b)
    mov [7], C
    mul [5], C, B
    mll [4], C, C
    add A, C, A
    mov [6], C
    mll [5], C, C
    add A, C, A
    ret

divMod16:   ; (uint16, uint16) divMod16 (int16 N, int16 D)
            ; (N, D) => (N / D, N % D)
    mov [5], 0
    jnz div16_if1_end ; if D == 0
    mov -1, A
    ret
div16_if1_end:
    push 0 ; [0] = Q <= 0
    mov 0, B ; B = R <= 0
    mov 15, C ; C = i <= 15
div16_for:
    lshi B, 1, B ; B = R <= R << 1
    rsh [4], C , A ; A <= N >> i
    andi A, 1, A ; A <= N[i]
    or B, A, B ; R <= R | N[i]
    mov [5], A
    sub B, A, 0
    jlt div16_if2_end ; if R >= D
    sub B, A, B
    lsh 1, C, A ; A <= 1 << i
    or [0], A, [0] ; Q[i] <= 1
div16_if2_end:
    subi C, 1, C
    jge div16_for ; end of for
    mov [0], A
    ret
